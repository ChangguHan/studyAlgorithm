// 최대인수 찾아서, 주변에 찾아보는 것,
// 불가 : 최대아닌데 4개값 합쳐서 최고일 수도 있으니까

// 모든 경우 확인해보는 수밖에 없는데
// 각각 4번 나가는거랑 동일한지?
// 동일할 것 같아
// 그럼 이거 시간복잡도
// N*N*4*4*4*4
// N*N * 5*2*4*4
// N^2 * 5*2^5
//2.5e5 * 2^8

// T모양 세울수가 없어서, 5개를 다해봐야할것같다


#include <iostream>
#include <queue>

using namespace std;

int N,M;
int map[510][510];
bool visit[510][510];
int tet[19][4][4] =
{
    // 일자
    {{1,1,1,1},{0,0,0,0},{0,0,0,0},{0,0,0,0}},
    {{1,0,0,0},{1,0,0,0},{1,0,0,0},{1,0,0,0}},
    // 네모
    {{1,1,0,0},{1,1,0,0},{0,0,0,0},{0,0,0,0}},
    // 뻐큐
    {{1,1,1,0},{0,1,0,0},{0,0,0,0},{0,0,0,0}},
    {{0,1,0,0},{1,1,1,0},{0,0,0,0},{0,0,0,0}},
    {{0,1,0,0},{1,1,0,0},{0,1,0,0},{0,0,0,0}},
    {{1,0,0,0},{1,1,0,0},{1,0,0,0},{0,0,0,0}},
    // 지그재그
    {{1,0,0,0},{1,1,0,0},{0,1,0,0},{0,0,0,0}},
    {{0,1,0,0},{1,1,0,0},{1,0,0,0},{0,0,0,0}},
    {{1,1,0,0},{0,1,1,0},{0,0,0,0},{0,0,0,0}},
    {{0,1,1,0},{1,1,0,0},{0,0,0,0},{0,0,0,0}},
    // ㄱ자
    {{1,0,0,0},{1,0,0,0},{1,1,0,0},{0,0,0,0}},
    {{0,1,0,0},{0,1,0,0},{1,1,0,0},{0,0,0,0}},
    {{1,1,0,0},{1,0,0,0},{1,0,0,0},{0,0,0,0}},
    {{1,1,0,0},{0,1,0,0},{0,1,0,0},{0,0,0,0}},
    {{1,1,1,0},{0,0,1,0},{0,0,0,0},{0,0,0,0}},
    {{1,1,1,0},{1,0,0,0},{0,0,0,0},{0,0,0,0}},
    {{1,0,0,0},{1,1,1,0},{0,0,0,0},{0,0,0,0}},
    {{0,0,1,0},{1,1,1,0},{0,0,0,0},{0,0,0,0}}
};
int tetN[] = {1,4, 2, 2,2,3,3, 3,3,2,2, 3,3,3,3,2,2,2,2};
int tetM[] = {4,1, 2, 3,3,2,2, 2,2,3,3, 2,2,2,2,3,3,3,3};


// int dy[] = {0,1,0,-1};
// int dx[] = {1,0,-1,0};
int maxv = 0;
// int sc=0;



// void dfs(int y, int x, int dep) {
//     if(dep==3) {
//         maxv = max(maxv, sc);
//         return;
//     }
//     for(int k=0; k<4; k++) {
//         int ny = y+dy[k];
//         int nx = x+dx[k];
//         if(ny>=0 && ny<N && nx>=0 && nx<M) {
//             if(visit[ny][nx] == false) {
//                 visit[ny][nx] = 1;
//                 sc += map[ny][nx];
//                 dfs(ny,nx,dep+1);
//                 sc -= map[ny][nx];

//             }
//         }

//     }
// }

void turn(int t) {
    int tetb[4][4];
    for (int j=0; j<4; j++) for (int i=0;i<4;i++) tetb[j][i] = tet[t][j][i];

    for(int j=0; j<4; j++) {
        for (int i=0; i<4; i++) {
            tet[t][j][i] = tetb[4-1-i][j];
        }
    }
    int tmp = tetN[t];
    tetN[t] = tetM[t];
    tetM[t] = tmp;
}
int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);

    cin >> N >> M;
    for(int j=0;j<N;j++) for (int i=0;i<M; i++) cin >> map[j][i];

    for(int j=0; j<N; j++) {
        for (int i=0; i<M; i++) {
            // 테트 종류
            for(int k=0; k<19; k++) {
                if(N-j >= tetN[k] && M-i >= tetM[k]) {
                    int sc=0;
                    for(int jj=0; jj<tetN[k]; jj++) {
                        for (int ii=0; ii<tetM[k]; ii++) {
                            if(tet[k][jj][ii]) sc += map[j+jj][i+ii];
                        }

                    }
                    maxv = max(maxv, sc);

                }

                // // 회전
                // for(int t=0; t<4; t++) {
                //     turn(k);
                    
                // }
            }
            // fill(&visit[0][0], &visit[509][510], 0);
            // visit[j][i]=1;
            // sc=map[j][i];
            // dfs(j,i,0);
        }
    }

    cout << maxv << '\n';

    return 0;
}
